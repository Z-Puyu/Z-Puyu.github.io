---
title: "HiveMind: A Web Lecture Note Editor"
date: 2023-7-24 20:00:00 +0800
categories: ["Portfolio Projects", "Software and Websites"]
tags: [projects, react, typescript, ts, javascript, js] # TAG names should always be lowercase
author: zpy
pin: true
---

> This project is registered under Orbital 2023 at the National University of Singapore. This project is certified at Apollo 11 level of achievement.
{: .prompt-tip }

## Motivation

For students with sensitive nerves of aesthetics, note-taking during lessons can be fraught with frustrating moments:

- To insert additional remarks, one has to resolve to either **messy scribblings** or **random post-it** notes along page margins.
- To mark out a linkage between concepts from different chapters, one has to populate the notebook with **long-winded arrows** and **unsightly symbols** to simulate a hyperlink.
- To just beautify the notes contents, one has to spend **tonnes of time** designing and polishing the layout and formatting of note-taking.
- Even for digital note-taking, the aesthetic sensibilities of many would get annoyed frequently by **unintuitive** editor UI, **misaligned** mathematical expressions, **ugly** tables and unstable text formatting that **goes hay-wire** with the insertion of a small illustration.

Similar situations like the above make us wonder: why does notes-taking — an important task of so many students — have to be so redundantly troublesome and inefficient? Thus, we wish to create a Web-based note-taking application that is simple to use and integrated with many popular features from the various text editors.

In the process, we hope to explore and learn the intricacies behind user interface and interaction design. In particular, we would like to make sense of what defines an *intuitive* UI, and how the various features of good interaction are implemented in code.

## Aim

By building a collaborative note-editing web-application with intuitive UI and navigation, we hope to alleviate students’ pain in doing repetitive and redundant refinement work in formatting or typesetting their notes, as well as enabling high-quality note templates to be circulated and readily accessible among peers.

## User Stories

1. As a student, I want to consolidate my learning and ensure that my understanding is correct by cross-referencing with others or group audit.
2. As a student, I want to replicate the structure with which other people have organised their notes, so that I can polish and condense my own notes more efficiently.
3. As a student, I want to hyperlink contents from different sections in my notes so that I can easily cross-refer between them during revision.
4. As a student, I want to insert additional annotations, exam tips and remarks during revision without disrupting the original structure and formatting of my notes.
5. As a student who learns better with visual guides, I want to borrow others’ aesthetic illustrations, graphs and tables to improve my own notes.
6. As a science-major student, I want a notes editor with built-in support for $\LaTeX$ so that I can typeset large amounts of mathematics with ease.
7. As a perfectionist student, I want the page layout, paragraphs, remarks, illustrations and equations in my notes to be aesthetically formatted without me having to make much effort.
8. As a lazy student, I don't see the point of writing my own notes from scratch, and want to collectively build a set of notes with my peers.

## Case Study on Existing Note-taking Tools

We conducted a case study on the various mainstream note-taking tools to learn about their features, advantages and pitfalls.

1. Google Docs
   - Pros
     1. Light-weight, fully accessible as long as one has a Google account.
     2. Easy to set up for collaborative editing and group audit.
   - Cons
     1. Requires network connection to save changes.
     2. Incapable of writing complex mathematics because only a small selected set of mathematical symbols is accessible.
     3. Inefficient to typeset equations — the user has to manually search for and click on the symbols from the drop-down GUI menus, instead of typing $\LaTeX$ commands directly.
2. Microsoft Word
   - Pros
     1. Nearly zero learning cost - every Windows user knows how to use it.
   - Cons
     1. Buggy text display on screen and potential crash may cause loss of work progress.
     2. Notoriously ugly look of typesetting of mathematical expressions.
     3. Incomplete support for $\LaTeX$ such that the user often has to guess which commands are available.
3. Overleaf
   - Pros
     1. Light-weight, web-based editor with project management features.
     2. Full-fledged support for $\LaTeX$ with the ability of importing third-party packages.
     3. Widely used in academia.
   - Cons
     1. Insufficient code highlighting and auto-formatting options, which potentially makes the code messy when writing complex mathematics.
     2. Does not support real-time rendering but instead re-renders the whole document for every re-compilation.
4. Vim/VSCode + TeXLive/MiKTeX
   - Pros
     1. Extremely flexible and customisable due to a large number of available plugins which enable a variety of fancy features.
     2. Full-fledged support for $\LaTeX$ with the ability of importing third-party packages.
     3. Support user-defined code snippets, which tremendously boosts the speed of typesetting.
     4. Extensive code highlighting and auto-formatting options.
   - Cons
     1. Fairly steep learning curve.
     2. Difficult to set up collaborative projects.
5. Markdown Editors (e.g. Typora)
   - Pros
     1. Easy to learn while still producing overall aesthetic documents.
     2. Simple syntaxes which allows efficient note-taking.
     3. Considerable amount of support for $\LaTeX$.
   - Cons
     1. Unable to render complex mathematics with detailed typesetting adjustments. For example, in most Markdown editors, `$\int\! f(x) \,\mathrm{d}x$` would get incorrectly rendered as $\int !f(x) ,\mathrm{d}x$.
     2. Difficult to set up collaborative projects.
6. Notion
   - Pros
     1. Very easy and efficient to adjust the order of paragraphs by dragging and dropping blocks.
     2. Support direct input of $\LaTeX$ code to typeset mathematics with real-time preview and rendering.
     3. A variety of custom blocks to cater to different types of notes.
   - Cons
     1. For people with experience in using $\LaTeX$, inserting inline mathematics is anti-intuitive as Notion uses its own custom hotkey combination to activate inline math mode instead of the standard $\LaTeX$ syntax.
     2. Does not support auto-completion of $\LaTeX$ commands.
     3. The equation block is flagged with the `displaymath` environment from $\LaTeX$ by default, which disables a lot of typesetting options.
     4. Uses KaTeX to provide support for rendering mathematics, which is less flexible because KaTeX only contains a limited number of $\LaTeX$ packages and disallows user-imported packages.

## Scope of Project

HiveMind is a **website application** for note-taking which provides extensive support for $\LaTeX$ to typeset not only most of the mathematics a student would need, but also plain texts using just standard $\LaTeX$ commands, so that there should be nearly zero learning cost in transitioning to HiveMind from any other $\LaTeX$ editor. Additionally, both inline and displayed mathematics should get rendered in real time as the user types in $\LaTeX$, so as to make typesetting mathematics as seamless and smooth as typing regular texts.

We envision HiveMind to be a modular editor. This means that every title, paragraph, equation, remark, theorem, definition, proof, problem... i.e., all parts and pieces that combine together to form the document for your notes, should be a component that can be freely moved and placed to any location in the document by simply dragging and dropping. We thus decided to study the features of Notion and emulate its block feature.

Regarding the tool to render $\LaTeX$ into webpage, we can use either KaTeX or MathJax which are both well-designed JavaScript libraries for displaying mathematics in the browser. With much research and contemplation, we eventually decided to use MathJax due to its better extensibility with third-party $\LaTeX$ packages.

## Features

### Modular Note-editing

#### [Proposed]

Inspired by Notion, we propose to make HiveMind a modular editor.

Inside every project the user has created in HiveMind, the main editor contains a list of editable components known as TeXBoxes. We name it as such because these are essentially text-boxes we see in editors like Microsoft Word, but their inner contents are rendered by $\LaTeX$ rather than as plain texts. By double-clicking on a TeXBox, the user can edit the contents inside it, and by click and hold on a TeXBox, the user can move the mouse to drag the TeXBox to some other location in the document, and release to drop the TeXBox there. This way, the user can adjust the order of paragraphs in a document as easily as moving a post-it note.

Beside plain texts, every TeXBox may also contain inline mathematics (or other inline scientific notations). Similar to a TeXBox, double-clicking on these inline components calls out a pop-up input area to edit the $\LaTeX$ statements corresponding to the mathematics displayed.

Graphs, tables, code blocks and other types of components in the notes should be able to get shifted around using the same drag-and-drop logic.

#### [Current Progress]

We employed **Slate.js** to implement the notes editor. This decision was made based on two main reasons:

- First, Slate.js is a relatively new library for making rich text editors with a very active user community, which means that it offers better support for more modern rich text functionalities and it is easier to find up-to-date resources and guide regarding the features we wish to implement.
- Second, the design philosophy behind Slate.js coincides with our project in many ways. One prominent instance is that Slate.js organises rich text components into different nodes, which are then packed into a tree structure based on their subsetting relationship. This highly resembles our idea of a modular editor consisting of different movable parts of contents.

With the extremely flexible components and methods provided by Slate.js, we quickly managed to transform the functionalities we have been experimenting on into a working prototype. Now we shall introduce the various functionalities implemented:

##### TeXBox

Paragraphs, headings and special text blocks like code blocks or quotes are packaged into modular containers known as **TeXBoxes**. On start-up, the editor is initialised with a single TeXBox containing an empty paragraph. All new paragraphs created by inserting line breaks will be automatically wrapped in a new TeXBox, and pressing Backspace at the start of a TeXBox will merge it with the previous TeXBox just like any normal text editor.

We do realise that sometimes there is a need for the user to insert a *soft break* (e.g. when writing code blocks, the user would not want to have every line of code in a separate box), so we also provide support for those use cases. To break a line without instantiating a new TeXBox, the user just needs to hold *Shift* or *Ctrl* while pressing Enter.

We have also implemented a variety of formatting options and a toolbar, which works just like any othe rich text editor. For example, to bold some texts, the user just needs to select those texts and press the "boldface" button in the toolbar. The currently supported formatting options are: **boldface**, *italic*, <u>underline</u>, <s>strike-through</s>, `inline code`, <a>link</a> and $\LaTeX \textrm{-rendered mathematics}$. These formats, except $\LaTeX$, can be composed onto one another freely, so a user can easily write <a><strong><i><u><s><code>some underlined inline code struck through and wrapped into a link with a boldface italic font</code></s></u></i></strong></a>, which can be more than a bit tiring to achieve in a markdown document like this (you have to nest 6 HTML tags to get it properly displayed but pressing 6 buttons will do the trick with our application).

Beside these inline rich-text formatting, we have also implemented special formatting options to block-level contents, including, `code block`, block quote, theorems, definitions, remarks and displayed mathematics. These also have their respective tooltip buttons in the toolbar to switch between different blocks. However, we realise that it is troublesome to frequently click on buttons to switch between block types, so we have added support for **slash commands**. The user can choose to, without leaving the keyboard, type in a **backslash** followed by a code snippet for the target block type, and press enter to instantly toggle the current TeXBox to the desired block type (More on this in section **Intuitive and Smooth User-Interface Interactions**).

We have also built rendering logic for heading blocks. We categorise headings into Part, Chapter, Section, Subsection and Sub-subsection, which are in line with the original heading options provided by $\LaTeX$. However, these have not been formally added into the editor for the time being, as we are still fine-tuning the indexing behaviour.

We have considered implementing support for different fonts into our application so that the user can freely choose the font to use from those installed in his or her device. However, we eventually decided to abort this idea. This is because most fonts *do not have sufficient support for mathematical and other scientific symbols*, which means even if we allow users to change the font of normal texts, these fonts will not be able to be applied to $\LaTeX$ rendering, causing a **unsightly inconsistency** between fonts of texts and mathematics just like you have seen in this document. So we resolved to fixing the font used in our editor ― but what font should we use then? There are two fonts that offer comprehensive support for scientific symbols, namely *Times New Roman* and *STIX Two*. We have chosen to use Times New Roman because it is the default font used by $\LaTeX$.

##### Drag-and-drop:

All top-level blocks of the document, i.e. TeXBoxes, are **draggable**. This means that should the user wishes to re-order the paragraphs, instead of copying and pasting big chunks of texts cautiously, he or she can just drag a TeXBox to the desired location in the document and drop it there. 

This mechanism has been implemented using **dnd-kit**. We chose to use this package instead of writing our own logic because of two reasons:

- First, we wish the mechanism to be complex enough to be able to sustain smooth user interactions. As such, using a mature package with pre-engineered methods would be much less bug-prone than building our own logic from scratch, especially considering our lack of experience with such mechanisms. We can instead make minor tweaks using the pre-existing methods to more easily achieve our desired behaviour.

- Second, dnd-kit allows all draggable components to be wrapped in its context provider. This means we can easily build a universal mechanism which is general enough to be extended onto every component we add to our application, thus reducing repetitive work. These context providers can then be nested, which means we can achieve different drag-and-drop behaviours for different blocks by simply overriding certain properties or methods without the need to write separate logic.

To ensure that the editor keeps track of the order of TeXBoxes correctly, we assign each TeXBox a unique ID, so that the editor identifies each element to be rendered using this ID instead of an array index which changes frequently under the drag-and-drop setting.

##### Automatic Numbering of Headings

An important feature that makes an editor feels "smart" is the ability to automatically index all headings and sub-headings in a properly formatted way. In our case, since we expect people who regularly use $\LaTeX$ to use our application, we also wish to implement this in a way which is similar to the original $\LaTeX$ logic.

Imitating the behaviour of $\LaTeX$, we configured 5 different header levels - namely **Part, Chapter, Section, Sub-section** and **Sub-sub-section**, in the order of descending importance and font sizes. Among these, parts are labelled using **Roman** numerals, while the others follow the format of `chapter + "." + section + "." + subsection + "." subsubsection` for indexing (so in the form like Section 1.3 or Sub-sub-section 1.4.3.2).

We achieve auto-numbering of these headers using the following way: every time the top-level nodes of the document updates, a utility function will fire, which interates all top-level nodes and retrieve all headers from there. After that, the function iteratively set the node properties of these header nodes to label them with the correct indexes. As such, the auto-indexing will be compatible with drag-and-drop.

Doing this has its pitfalls: the order of the headings does not necessarily change when the document nodes alter. For example, appending a new paragraph to the end of the document does not add new headings nor shift existing ones around. However, our utility function will still fire nonetheless to re-calculate the headers' indexes which will essentially be identical. Therefore, we have compromised some efficiency due to these redundant calculations.

On the other hand, we still decided to keep it this way despite this known issue because we realise that a more efficient algorithm may grow in syntax complexity drastically, which makes it more bug-prone and less easy to debug. Meanwhile, despite the redundancies, our original algorithm is still bounded by $O(n)$, so the marginal benefit of optimising would be minimal.

Regarding theorems, definitions, examples and problems, the numbering of these blocks is achieved with a similar algorithm but with a small tweak. For each of the theorem blocks retrieved from the document nodes, we will locate the first **section header** before it. If this theorem is the $n$-th theorem block in that section, its index is determined by `sectionIndex + n`. So for instance, the 2nd theorem under section 1.3 is labelled as Theorem 1.3.2, and the 5th problem under section 2.2 is labelled as Problem 2.2.5.

#### [Potential Addtions]

Here we list a few good-to-have features:

1. Syntax highlighting for code blocks which support different programming languages.

2. Smoother animations during dragging and dropping blocks.

3. "Transfer Station" which hosts temporary copies of blocks deemed potentially useful by the user, such that the user can retrieve them directly from the station to paste in the appropriate position without needing to browse back and forth to search for the blocks. 

4. Ability to chain up neighbouring blocks and move them around together.

However, it is unlikely that we have sufficient time to implement these nice features due to their complexity and the fact that our team have to prioritise on other essential functionalities of the application first.

### Intuitive and Smooth User-Interface Interactions

#### [Proposed]

It is great pain when one has to frequently switch between the keyboard and the mouse while editing a long document like lecture notes. Not only does it slow down typing, but it also disrupts the note-taking and thinking processes. Therefore, we aim to build the logic for the user interface such that only a minimal, if any, number of actions need to be completed with the mouse. Ideally, the user should not need to leave the keyboard during the whole process of note-editing except to re-order the modular components. For instance, the following features will be implemented:

1. The user can switch between neighbouring TeXBoxes by Ctrl + Up and Ctrl + Down key combinations. The hotkeys are designed as such because TeXBoxes are arranged as a vertical array.
2. When the caret reaches either inline or displayed mathematics, the $\LaTeX$ input area will pop up automatically either on top or below the selected mathematics. Intuitively, the user can press Up or Down keys respectively to enter the input area. Otherwise, the user can continue to move the caret away.
3. After editing in the $\LaTeX$ input area, the user can click the confirm button, press Enter, or click anywhere outside of the input area to exit it, which would also set the caret right after the mathematics automatically.
4. Special actions such as opening a new $\LaTeX$ environment to insert displayed equations, making new sections or titles should be binded to either hotkeys or slash commands.

#### [Current Progress]

##### $\LaTeX$ Rendering and Display:

$\LaTeX$ rendering is of particular importance to our application so we decided to first tackle the various interactions with it. We have spent much time and effort contemplating and experimenting in order to find out the best way to implement it for the optimal user experience. In the very initial implementation, an input box will pop up and get focused when inserting an inline math component for the user to type in $\LaTeX$ code, and the rendered result will be displayed in the TeXBox. 

However, $\LaTeX$ cannot be rendered in the browser in the same way as texts and it *blocks cursor movement* (the caret will disappear when one attempts to move it across the inline mathematics). Hence, to ensure browser-compatibility such that the caret is not obstructed, we had to make the rendered inline mathematics a **read-only** block so that the caret "jumps over" it when direction keys are pressed. One severe problem this had led to was that a read-only block *cannot be selected* (actually there might be a possible walk-around but it could be highly tedious and bug-prone), so the user has to click on the block to activate the input box, and click on the paragraph after closing the input box to focus on the texts again. **This deviated from our vision of a mouse-free user experience.**

In searching for an alternative, an inspiration struck: instead of using an **inline display + hovering input box**, can we switch them and use an **inline input + hovering preview box** instead? Following this idea, we rebuilt the input mechanics for $\LaTeX$ such that the user can insert a $\LaTeX$ block by either clicking the math-mode tooltip button or pressing "\$", after which the user can directly type in $\LaTeX$ code. Since $\LaTeX$ code consists of just regular characters, it can be typed just like any other normal text. This $\LaTeX$ code then gets automatically wrapped inside an inline element, from which a hovering box will pop up to display the rendering result of the code. 

When the user completed, he or she can return to normal text mode by simply moving the caret away from the inline element containing the $\LaTeX$ code, which will then be replaced by the rendered mathematics. Note that in this implementation, the $\LaTeX$ component is no longer read-only but an **editable inline element**. This means that it can be selected and focused in the regular way. Therefore, when the user moves the caret into the inline mathematics, the $\LaTeX$ code will become visible and the preview box will appear again automatically, and mouse clicking is no longer necessary.

In the newest version, we have also added support for more environments for displayed mathematics, so that the user can input things like systems of equations, matrices and multi-line expressions with ease.

##### Hotkeys and Toolbar

Besides implementing $\LaTeX$ input, we have also added hotkey bindings for the text formats currently supported in our editor. The list is as follows:

- mod + b: boldface

- mod + i: italic

- mod + r: regular

- mod + u: underline

- mod + s: strike-through

- mod + `: inline code

- mod + k: link

All of the above hotkeys have their tooltip button equivalents in the toolbar. Toggling a format with texts selected will apply the format onto the currently selected texts, whereas toggling a format with a collapsed selection will cause the proceding input from the caret position to be applied with the format.

Regarding the toolbar, we initially appended it to every block in the editor, but this soon led to a problem: most text formats such as boldface and italic texts are not used at all in certain special types of blocks such as a code block, so it is **redundant** to still show the toolbar in those blocks. Therefore, we decided to make the visibility of the toolbar conditional such that it only shows up in a text block (e.g. paragraph and heading) while it is focused. An unexpected benefit this has brought is that the editor now looks cleaner because there can only be at most one visible toolbar concurrently. 

Additionally, since the toolbar is invisible in certain special blocks such as a code block, we placed the block-toggling buttons at a separate toolbar which is always visible.

##### Slash Commands:

Inspired by Notion, we have found that slash commands are a very useful feature to reduce the frequency of mouse-clicking while using the application, which offers a great boost to efficiency. So we decided to incorporate it into our application as well.

To initiate a slash command, the user simply types a **backslash**. The reason why we chose to use a backslash ("\") rather than a slash ("/") is that many custom $\LaTeX$ environments are also delimited with slash commands (\begin{...} and \end{...}), so a $\LaTeX$ user would be more accustomed to inputing a command with a backslash. Additionally, this also potentially makes it possible to integrate more $\LaTeX$ environment into our application.

Once a backslash is typed, an inline input for commands will be triggered. At the same time, a select menu will appear right below the command input to show all the possible commands available. As the user types in the command input, the options in this menu will be **filtered** in real time such that *only commands which contain the current input will be displayed*, which behaves just like the code suggestion menu in many IDEs like VSCode.

The user can click on a command from the select menu to apply it to the currently focused block. For now, this refers to toggling the block type, but we may add other kinds of commands in the future. Alternatively, the user can also use the ArrowUp and ArrowDown keys to browse the menu and change the selected command, and press Enter to apply the selected command.

We did predict that the user may want to type something after a backslash only as regular texts instead of a command. To address such a use case, we have designed the command input such that it will only become active when the caret is next to any character of the command. Hence, when the user moves the caret away from the slash command, it will just display as normal texts. Moreover, whenever the user initiate a new command input, the editor will first iterate through all texts within the same block and *unwrap all existing command inputs into plain texts*. By doing so, we aimed to avoid potential bugs caused by multiple active commands present in the same block.

##### User Interface (UI):

We recognise that good UI design forms a major part of positive user experiences, and is therefore essential for implementing smooth user interactions. Hence, we decided to build the UI in parallel to the logic of our application, rather than adding interface styling only after a prototype has been completed. This had the following advantages:

- By drafting out the basic layout of various UI components, this helped us as developers better visualise the appearance of our application and thus predict how a user would react to the webpage, so that we could make more informed decisions on the most ideal kind of interactions to implement for the various interfaces.

- To the users who test our application, having relatively complete UI components would help simulate what the application might turn out to be in the final version, so that their experiences with the prototype would be closer to the actual product, which helps them make more concrete comments on the various features of our application. As developers, this means when we start overhauling the UI in the next phase of development, we would already have a lot more of useful information and feedbacks in mind.

Initially, we planned to design most of the UI components from scratch. However, we proved to have underestimated the complexity of UI design, which has led to problems. For instance, we created some unnecessary nesting of components which over-complicate the structure of our code. Furthermore, there were some components which were initially abstracted into stand-alone files but later discovered to be unlikely to get reused, so such abstraction barriers seem redundant. These UI components built from scratch were also unstable and prone to changes in styling, which made our application harder to maintain.

Therefore, we decided to switch to a UI library instead. We have chosen to use MUI to build our user interface. This decision was mainly because MUI by default uses Emotion to style its components, which we had already been using earlier in many of our own components, so it would be easier to migrate those components to newer versions based on MUI. Furthermore, MUI has a minimalistic design which suits the overall theme of our application's aesthetics.

By now, we have mostly finished migrating to MUI framework. Additionally, we also implemented some animations which add semantic indications to these UI components. For example, a floating tooltip will appear when the user hovers the cursor on a button in the editor's toolbar containing a short description of the button's function and its hotkey; hovering the cursor on the drag-and-drop event listener will change its opacity, while the cursor changes to the grabbing form to hint user interactions; select menu items and various buttons will change colours based on the current state of activation to serve as a better visual guide to the user.

### Real-time Rendering of $\LaTeX$ Contents

#### [Proposed]

One limitation to most $\LaTeX$ editors is the lack of real-time preview of the code entered. Note that in $\LaTeX$ we often need to typeset things like:

```LaTeX
\begin{align*}
    L & = \int_{1}^{2}\! \sqrt{1 + \left(\frac{\mathrm{d}y}{\mathrm{d}x}\right)^2} \,\mathrm{d}x \\
      & = \int_{1}^{2}\! \sqrt{1+(2(x-1))^2} \,\mathrm{d}x \\
      & = \frac{1}{2} \int_{0}^{\tan^{-1}2}\! \sec^2\theta \sqrt{1 + \tan^2\theta} \,\mathrm{d}\theta \\
      & = \frac{1}{2} \int_{0}^{\tan^{-1}2}\! \sec^3\theta \,\mathrm{d}\theta
\end{align*}
```

For long mathematics like this (which is yet to be considered as "complex"), the user has to frequently re-compile the document to preview the rendering result, which is troublesome and time-consuming as it can be slow to re-render a long document. Therefore, we realise that it is important to incorporate $\LaTeX$ such that mathematics produced would get rendered in real-time.

#### [Current Progress]

We have employed the **better-mathjax-react** Node package to help implement $\LaTeX$ rendering. After entering math mode, the mathematics rendered by MathJax as preview will synchronise with the $\LaTeX$ statements typed.

We wished to improve further such that the rendered mathematics only updates when the $\LaTeX$ statements in the input area is legal and complete. Otherwise, the mathematics displayed remains the same as before the change in $\LaTeX$ code. The intent of this proposed improvement was to prevent the user from seeing flashes of incomplete rendering or error messages from $\LaTeX$ compiler. However, "better-mathjax-react" is engineered with the technical pitfall where only static contents are allowed if we were to configure the rendering process to be such, i.e. the user will not be able to edit the $\LaTeX$ code to be rendered once it is initialised. Therefore, we had to discard this idea.

We have also made use of the $\LaTeX$ rendering mechanism to add an optional proof section for theorem blocks, which can be activated with a slash command.

### Hyperlink between Notes Components

#### [Proposed]

Concepts in different chapters may have interconnections with one another, and therefore it is useful to be able to quickly cross-refer back and forth between these related concepts while revising using the notes. Thus, we plan to implement hyperlinks in HiveMind to allow the user to set markers to related components, so that later the user can simply click on the marker to jump between the various parts.

For example, the user can set up a marker at a formula, and set up another marker at the definition from which the formula is derived, so that when the first marker is clicked, it will lead the user to the location of the definition.

Ideally, a marker should be able to be set at an arbitrary number of locations. This means that the user can link ten different equations with one marker, such that when this marker is activated, it calls out a menu where the user can select which location to jump to. The user can annotate each of the locations with a custom tag to serve as a brief description of the contents over at the referenced position.

#### [Current Progress]

While our original plan seemed reasonable, we soon discovered that some parts of it were not as practical as we expected. For instance, we wished that one single hyperlink marker could link up any number of parts in a set of notes, but in practice, such a system over-complicates the mechanics of note-editing. In particular, it requires highly complex state management to build the hyperlinks, which appears not very efficient. Moreover, it poses another challenge to implement the user interfaces for such a system as there could be too many markers associated to one hyperlink to be displayed succintly. As such, although we still think it is a good idea to have a system like what we originally proposed, we decided to simplify the implementation details and build a simpler version first.

Currently, the user can insert *bookmarks* which are read-only inline elements beside sections deemed as important. We spent some extra care designing the display of the bookmark. Each bookmark has three attributes: **a title**, **a destination** and **a custom description**. By default, every bookmark has a title which will be displayed. The destination is an optional attribute which refers to the section to which the bookmark is linked. For example, if bookmark A has a destination of bookmark B, then the former will be displayed as "Refer to bookmark B" and the latter, "Refer to bookmark A". Finally, if a bookmark has a custom description, that description will take the highest priority as its display name. By doing so, we have created a display mechanism for the bookmarks with three layers of fallbacks, which enables more dynamic user control over the appearance of the bookmarks.

Double-clicking on a bookmark calls up a configuration menu where the user can customise all three attributes by simply editing in the corresponding input fields. The destination section has an extra filter which will display all matching bookmarks from a drop-down menu filtered based on the current user input. For example, if the user has typed in "abc" in the input, then only bookmarks whose titles start with "abc" will show up for selection. This allows the user to locate and select the target bookmark faster.

The linkage relation is by default **symmetric**, meaning that once bookmark A is defined with its destination as bookmark B, bookmark B will automatically be updated to have bookmark A as its destination as well. This means that clicking on these two bookmarks allows the user to quickly toggle back and forth between the two sections.
