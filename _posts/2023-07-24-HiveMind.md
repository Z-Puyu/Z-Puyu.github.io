---
title: "HiveMind: A Web Lecture Note Editor"
date: 2023-7-24 20:00:00 +0800
categories: ["Portfolio Projects", "Software and Websites"]
tags: [projects, react, typescript, ts, javascript, js] # TAG names should always be lowercase
author: zpy
pin: true
---

> This project is registered under Orbital 2023 at the National University of Singapore. This project is certified at Apollo 11 level of achievement.
{: .prompt-tip }

#### [Potential Additions]

We could continue exploring to see whether there is an efficient way to upgrade the bookmark linkage such that an arbitrary number of bookmarks can be linked.

Furthermore, a new inspiration derived from working on the bookmark and hyperlink feature is an **index page** for notes. Based on the headings present in the current notes, we could build a mechanism that auto-generates an index page at the very beginning of the document, where each entry is hyperlinked with the corresponding heading. This hyperlink should behave very similar to the current bookmark feature we have implemented.

### GUI-based Illustration Maker

#### [Proposed]

Making beautiful graphs and diagrams with $\LaTeX$ can have a very steep learning curve, but it provides a high degree of precision which is hard to emulated with other illustration makers. Therefore, we propose to build a GUI-based illustration maker inside the editor of HiveMind which hides the specific $\LaTeX$ code behind an abstraction barrier and allows the user to generate aesthethic illustrations with a more visual interface. This illustration maker should be applicable to at least the following items:

- Matrices
- Tables
- 2D graphs
- Geometric diagrams

#### [Current Progress]

This has been a particularly challenging feature to build throughout the project, and while we have managed to implement the core functionalities, the overall result has not been satisfactory.

##### Matrix Builder

The matrix builder has been implemented the most comprehensively. The user can type in the size of the matrix and fill in the entries in a grid, while the output will be displayed in a preview box in real time. We managed to add three quality-of-life improvements to this seemingly simple system which aim to suit some niche but important demands for people who need to input matrices frequently. First, the matrix builder offers an option to generate a grid for an *augmented* matrix, which can be toggled on and off with a switch. Second, there is a select menu from which the user can *change the delimiters* of the matrix between parentheses, square brackets, curly braces, modulus and norm. Third, we provide a series of buttons to instantly perform some special matrix transformations, which are:

- Produce an identity matrix of the given size.

- Produce a zero matrix of the given size.

- Change the current matrix to an upper- or lower-triangular matrix.

- Change the current matrix to a diagonal matrix.

- Transpose the current matrix.

After the user is done with creating the matrix, clicking on the insert button will add the matrix as a display math block into the editor. While it is still fully possible to type in a matrix manually using the `array` environments of $\LaTeX$, the matrix builder offers a more visual framework to create matrices more efficiently.

##### Function Plotter

Originally, we planned to make use of the `tikz` $\LaTeX$ package to build our function plotter. Unfortunately, however, this package is not compatible with MathJax which is essential to display $\LaTeX$ in the browser. This almost put us into a dead end as most libraries for creating charts and diagrams focus on Microsoft-style illustrations rather than mathematically precise and professional graphs.

Luckily, there is still a library which we have found to be usable, which is **Mafs.js**. However, this library is far from being optimal for our use case as what it does is to map a **JavaScript function** to a mathematical plot, and so we have to find a way to first convert $\LaTeX$ syntaxes into a JavaScript function.

During our search, we finally decided to use **Cortex.js** and in particular, its **ComputeEngine** library. The logic of Cortex.js is to represent a mathematical operation with a tuple containing the names of the operator and the operands. For instance, the JavaScript function `Math.sin(x)` or equivalently in $\LaTeX$, `\sin(x)` is represented using `["sin", "x"]`. Naturally, these tuples can be nested in to what is known as a **MathJSON** object to represent composed functions. For example, the MathJSON object `["add", ["multiply", ["divide", 1, "x"], ["sin", "x"]], 5]` represents the function `Math.sin(x) / x + 5`. By using MathJSON as a bridge, we can convert a user input string written in $\LaTeX$ into an executable JavaScript function, which can be then passed in to Mafs.js to plot the function.

While we managed to get the plotter working, there are huge pitfalls with the current implementation. The evaluation of a MathJSON object is extremely expensive as we have to recursively replace of occurrences of `"x"` in the nested tuple with the value to be substituted in. For any mathematical expression with reasonable complexity, the corresponding MathJSON can already have a very high degree of nesting, not to mention the sheer number of values we have to substitute into the MathJSON to plot the graph. As a result, the behaviour of our function plotter has been very slow and laggy, and so far we have not found a viable alternative to implement it.

Moreover, the internal implementation details of the Math.js library has determined that it only accepts pure strings as label texts, which means there is no way we can label the plotted functions with accurate mathematical texts. Due to these prominent issues, we decided to postpone the implementation for geometric diagram maker indefinitely.

### Project Management System

#### [Proposed]

The project manager of HiveMind is inspired by Overleaf. Instead of behaving like conventional document managers that group files into folders, the project management in HiveMind is done via tags.

The user first create some custom tags, and then assign the tags to the projects to indicate some shared characteristics among them. For example, a user might want to tag all his maths notes with "Math" and all his physics notes with "Physics". The advantage of using tags is that the same project can be placed to a number of different groups. For instance, the notes for computational genomics may appear under "CS", "Math", "Statistics" and "Biology" tags such that clicking on any of the four groups is able to access the project.

#### [Current Progress]

We chose to use Firestore to build our back-end server for data storage.

##### User Authentication:

Currently, we have built the authentication page. The user can choose to register and log in with an e-mail and a password, or sign in with a Google account. To register a new account, the user inputs his or her user name, an e-mail address and a password. 

We have implemented validation rules for user registration as follows:

1. The user name may be identical to someone else's.

2. However, the user e-mail must be **unique** to every user, a registered e-mail cannot be used by a new user again.

3. The password must contain at least 8 characters, including at least one alphabet and at least one number.

4. The user needs to repeat the password to check if two password inputs match.

If the user input does not pass the validation checks, the registration will fail and a helper text will be displayed under the input field. After submitting validated registration data, a verification e-mail will be sent to the registered e-mail address. Once the user has verified the e-mail address, he or she can then enter the application's dashboard.

After successful registration, the user will be automatically signed in. Afterwards, the user can use the registered e-mail and password to log in any time. If the user forgets his or her password, he or she can request a password-reset e-mail be sent to a designated e-mail address.

The user's avatar and user name will be displayed in a badge in the navigation bar. Clicking it will direct the user to his or her profile settings where he or she can edit the user name, change the avatar icon or add a short personal description.

We store all the user information under the "users" collection in Firestore. When a user logs in, we first query the database for documents under the collection which has the same ID as the current user credential (for Google sign-in) ot the same user e-mail (for regular e-mail and password sign-in). If such documents do not exist, we follow up by adding a new document containing the current user's information to the "users" collection. If the user has successfully logged in, we will redirect him or her to the Dashboard. Otherwise, the website will alert the user with an error message.

##### Project Manager:

On Firestore, we created a "userProjects" collection, which contains all users that have been registered with our application. Each user points to a sub-collection named "projects" where all the projects owned by the user are stored. Once the user is directed to the Dashboard, he or she will see the project manager. The application will send a request to the database to retrieve the data of all of the user's projects and display them as entries of a vertical list. 

Currently, every entry will display the file name, tags, owner's user name and the date of last update of the project, and the projects are ranked in order of last update time by default. Alternatively, the user can also rank the projects by file name or owner's user name. Clicking on the corresponding table heading cell switches between ascending and descending ranking. Clicking on the entry will re-direct the user to the editor page with the corresponding project loaded. All changes of project contents thereafter will be automatically saved in real time to the database.

The user can click on the "Create New Project" button to set up a new project, which pops up a window for the user to enter the project name. On pressing "confirm" button, the application will first check the validity of the project name. If the project name is empty or is the same as another existing project, the webpage will alert the user with a message. Otherwise, the new project will be created successfully and its data will be send to the database.

The user can also rename or delete a project by clicking on the corresponding button beside the entry in the manager. When renaming, the same validation process for project name applies. 

To help new users quickly learn the various features of our application, their project manager will have a default example project on successful registration.

##### Tag Management

The user may group several projects together using **tags**. To create a new tag, the user needs to click on the "New Tag" button and gives the tag a unique name and a colour. After the tags have been created, the user selects the projects to be grouped together by clicking the check boxes beside the project names, and click on the desired tags from a drop-down menu to apply them to (or toggle them off) the selected projects.

Once successfully associated, the tags will be displayed beside the projects' name. There is a tag management panel to the left of the project manager, where the user can select one or more tags, so that only the projects containing the selected tags get displayed. 

#### [Potential Additions]

There are some notable additions that we could make to the project management system, for example:

1. The user should be able to export the projects, for example as PDFs.

2. The time stamp displayed for each project should be more precise to minutes instead of just dates.

Furthermore, we would continue building on the authentication process. We plan to add other login methods such as Facebook and Github. 

There are a few potentially complex features that could be added to the project manager. For instance, since our editor supports $\LaTeX$ input, it would be good if a user can import $\LaTeX$ source code, which can then be converted to a project.

It would also be good if the user can export $\LaTeX$ source code directly from an existing project so as to transfer the notes to other platforms such as Overleaf.

Regarding project management, we could add a functionality which allows the user to mark certain projects as "important" so that these projects will always be pinned to the top of the project manager regardless of ranking rules.

### Collaborative Note-taking

#### [Proposed]

What is the point of taking down notes for everything on your own, if your peers are also taking notes for the very same contents? In our everyday experiences, we realise that a large part of notes contents would appear to be very similar among different students taking a certain course. For example, the notes on the epsilon-delta definition of limits would be exactly the same for all students learning calculus. This means that instead of each making his or her own notes, it suffices for all these students to share one set of notes.

Thus, we propose to incorporate collaborative editing into HiveMind. Users may create and share collectively owned projects to co-edit or conduct group audit, allowing higher efficiency in note-taking as a group. At the same time, this also allows one to take reference or gain insights from the notes written by someone else, after which he or she may find it helpful to copy over the section to his or her own notes.

##### [Current Progress]

We divided the work of this feature into two major parts: first, the user should be able to search for and share a project with other users so that they have the access to edit the same project; second, changes from different users should get synchronised in real time on every collaborator's front-end.

##### Project Sharing

In the dashboard, the user can select a project and click on the "Share" button to grant other users access to editing it. To search for a user, one can either type in the user name or the user's registered e-maill in the search box. Once an input is detected, the application iterates through all user data in Firestore and retrieve the entries with (partially) matching user names and e-mail addresses.

The retrieved users will then be displayed in a drop-down menu under the search box. Clicking on a user will add the user to the collaborator list for the currently selected project. After confirmation, all users in the collaborator list will have access to the project, and the project will show up in their dashboards for them to view and edit it.

##### Group Editing

The group editing feature has not been implemented up to our original expectation due to the internal constraint of the Slate.js library which we have used to build our editor.

Slate.js does not provide built-in support for syncing contents across different instances of its editor, and thus we have to build the synchronisation mechanism on our own. We were faced with two options: we could choose to reload the document nodes once after some fixed time interval, so that the newest contents from Firestore will be retrieved and updated for the current collaborative project; alternatively, we can also monitor the operations applied to the project such as inserting texts or moving paragraphs, and send these operations to the other collaborators and apply them concurrently.

After some contemplation, we resolved that the first option was not feasible as changes could occur very frequently from multiple sources under a collaborative project setting. If we were to update these changes in real time, this would lead to an extremely expensive algorithm, compromising efficiency greatly. On the other hand, if we only refresh the editor after some fixed time interval - say once every 5 seconds - that would severely affect the smoothness of the collaboration.

Therefore, we decided to do the following: when a user applies some change to the document, we detect the type of operation for that change and send it over to all the other users in the collaborator list. Once the operation is received by the other users, it will immediately be applied to their copies of the document. The advantage of this is that compared to monitoring the entire document contents - which could be very extensive - syncing only single operations across multiple editor instances is a *low-cost* operation, which allows us to synchronise contents between different collaborators efficiently in real time.

To achieve this, we incorporated **Socket.io** into our application and built a server with **Express.js** to send and receive data in real time. The detected operations will be sent to the server first, and after the server receives the data, it then broadcasts the data to all other connected users. At the user's side, we first examine the **source** of the incoming data by keeping track of the project's user ID and document ID. If the user ID and document ID are the same for the incoming data and the local project, then we know that the operations contained in the incoming event have occured in the current project. On top of that, if the user ID from the incoming data differs from the current user who received the data, we know that the data is a *remote* change and should be applied to the current document. Otherwise, the user who receives the data is the same as the user who sends it, meaning the change is a *local* one and has already been updated, so it should not be double-counted.

##### [Potential Additions]

In most other collaborative editors, features like decorated cursors to indicate the presence of collaborators and commenting are commonplace. However, these are complex mechanisms which we lack the time to implement from scratch.

We did find a third-party library called *slate-yjs* which incorporates *Y.js* into Slate.js to achieve synchronisation and various decorative features for collaborative editing. However, this library has made significant changes to the structure of the editor component from the original Slate.js and it is therefore difficult to include it into our application without doing a major overhaul. In the future, however, we may rebuild the application using this framework to provide better support for collaborative editing.

## Tech Stack

1. React.js
2. JavaScript, TypeScript
3. Firebase
4. Node.js
5. Slate.js
6. MathJax
7. $\LaTeX$

## Problems Encountered and How We Fixed Them

With both members as complete novices in software development, our team has had a hard time during the initial stages of our project. Though we had to spend much extra time tackling all kinds of issues we have encountered, these have later turned into invaluable learning experiences for us. Here we document several notable and major problems that appeared in the process of our project development.

### The Pain of Re-building the Wheels

Our project aims to tackle a relatively niche issue: **increasing the modularity of digital note-editing with comprehensive** $\LaTeX$ **support.** The one immediate problem we had to face was: there is little resource online that is directly relevant to our development. Most people who need large amount of $\LaTeX$ typesetting will just use a $\LaTeX$ editor or choose to write in Markdown anyways. Therefore, there are very few examples for such a note editor from which we can take reference. As such, we had no choice but to learn from and emulate other types of applications like a regular rich-text editor, which proved to be of great pain.

Our inexperience also led us to being *overly (or na√Øvely) confident* to the extent that we believed we could achieve our targeted outcome by building everything using plain React alone. We simplistically thought that one contentEditable `<div>` would suffice for building an editor, but the mechanism behind a simple editor appeared far more complicated than it seemsed. We then resolved to using the content-editable Node package, but later realised that a simple and light-weight package like this could not cover our needs at all. As a result, by Milestone 1, only a very small fraction of our plan has been implemented, which was barely kept from breaking apart. It was by then that we realised that we urgently need to seek for a **comprehensive framework** which specifically targets editor development, and we finally found *Slate.js*.

The advantages of Slate.js have been discussed in earlier sections so we shall skip them here. Nevertheless, what happened afterwards proved one important thing to us: *it is always better to adopt a ready-to-use tool than to build the wheels from scratch.* Even if the library does not fit your needs 100%, it would still be way more efficient to improvise using existing tools than to construct everything on our own. 

We managed to rebuild our application from the previous mini-demo within only half a day. Since then, we finally have had a stable foundation for our application that can be easily extended with new functionalities.

### Dilemmas in Design Decisions

We had wished that we could always find the "best" or the "ideal" way to implement every single functionality for our application, but we have been proven wrong. There are times where every possible implementation brings along some seemingly "unacceptable" pitfalls.

The most prominent instance is when we were implementing rendering logic for displayed mathematics. As a jargon for mathematical typesetting, "displayed mathematics" refers to mathematics which occupies its own lines which are disjoint from regular text flow. Examples of displayed mathematics include

$$
\lim_{n \to \infty}\left(1 + \frac{1}{n}\right)^n = \sum_{n = 0}^\infty \frac{1}{n!} = \mathrm{e}
$$

and other kinds of often complex mathematical expressions.

You will notice that although displayed mathematics seem to occupy separate "paragraphs", they in reality carry semantic meanings and act as some part of speech in a full sentence. Thus, it is justified to implement displayed mathematics as **nested blocks** within a paragraph. 

However, an issue soon emerged. We noticed that if a paragraph ends with displayed mathematics, an empty line will appear after the mathematics, which makes the gap after that paragraph inconsistently wider. What was worse was that we soon realised that there was practically no solution for it because it was caused by an inherent constraint of Slate.js. Slate.js uses an **empty string** to indicate the end of a top-level block, and since our displayed mathematics took away the full width of the block, Slate.js had to insert that empty string to the next line, leading to the empty line problem.

We then considered re-building the displayed mathematics as its own top-level blocks. However, because the mathematics serves as a part of a complete sentence, this would cause one sentence to be fragmented into three different blocks, which was aesthetically weird. Moreover, as our editor needed to include blocks for theorems, definitions, remarks, solutions and proofs, it would not make sense if those blocks have to split up whenever displayed mathematics needs to be inserted.

Eventually, we decided to compromise. We judged that issues due to empty lines would occur much less frequently as compared to potential broken blocks would do if we make displayed mathematics into top-level blocks. The encounter with such a dilemma has taught us that we often have to weigh the pitfalls between several non-ideal implementations and choose one, rather than to seek a "perfect" solution that is impractical.

### Bugs with the Bookmark Feature

In the features section, we mentioned that we wish to hyperlink important sections with bookmarks such that clicking on them allows the user to jump instantly back and forth between these sections. We planned to achieve this by associating each bookmark with a **destination**, represented by an optional property in the type declaration for the bookmark object.

Initially, we thought that it was the most straight-forward if we just implement the destination as another bookmark object. For example, when marking Bookmark B as the destination for Bookmark A, we simply assign Bookmark B to the destination property of Bookmark A, like this:

```typescript
// Type declaration
type Bookmark = {
    // Other properties
    dest: Bookmark;
};

// Bookmark A
a: Bookmark = {
    // Other properties
    dest: b,
};
```

If it worked as intended, we could then use the built-in methods of Slate.js to convert the bookmark node in the editor to a DOMNode (or an HTMLElement) and use the `scrollTo` method to perform the jump between sections.

However, we soon noticed a bug: after configuring Bookmarks A and B as such, the linkage between them could not be saved! When we closed the editor and opened it again, the hyperlink between them disappeared and clicking did not work as expected. Moreover, when we tried to re-configure them, we received error messages from time to time.

With some testing, we quickly located the problem. It was because our bookmark hyperlinks represent a **symmetric relation**, meaning that the code above would actually be:

```typescript
// Type declaration
type Bookmark = {
    // Other properties
    dest: Bookmark;
};

// Bookmark A
a: Bookmark = {
    // Other properties
    dest: b,
};

b: Bookmark = {
    // Other properties
    dest: a,
};
```

Looking at `a`, since the value `b` of its `dest` property is also a Bookmark object, `b` would contain a `dest` property whose value is `a`. This essentially reduced to an infinite loop and cyclic dependency which broke our code.

Hence, we needed another way to store the destination data. We though of using the *paths* of the corresponding bookmark nodes, which are structures provided by Slate.js representing the relative position of a node in an editor with respect to some root node. However, this idea was aborted before it was implemented, as we realised that the path of a node is mutable in our application due to the drag-and-drop mechanism.

This pointed us a direction: we require an *immutable* value to represent and record a bookmark node! We happened to have already such a value associated with every node in the editor: previously when we implement the drag-and-drop logic, the library we used requires that every draggable element should have a unique ID. Therefore, we could just use that unique ID to manage the bookmark hyperlinks. 

Through solving this bug, we have learnt the important lesson that we should always avoid cyclic references in our code, and re-use pre-existing structures to solve problems as much as possible.

### Lack of Sufficient User Testing

As of the current stage, our application has gone through a few rounds of user testing where we as developers as well as some of our friends as users have tried out the application. Through these testings we have managed to spot and fix a number of bugs and problems with our application.

However, through the process we have also discovered another equally important purpose of user testing, which is to open up new inspirations for areas of future improvements or alternative implementations for existing features. Compared to fixing bugs, this can be even more valuable as it helps an application to grow and upgrade in the long term.

To effectively achieve this goal, though, it requires a higher number of testers from a variety of backgrounds, as different users will have vastly contrasting habits when it comes to using an application. In this sense, our testing for the application is still lacking of sufficient testing with a focus for this area.

## Proof-of-concept and Demonstration Project

The [project poster](https://drive.google.com/file/d/1dL180YuiV-PIWLBDEUgYuJS8fi1AkTxh/view?usp=sharing) and [project video](https://drive.google.com/file/d/1jKPr2qM6JK-PTmRO0F_hU6YwX8UCQqUH/view?usp=sharing) can be accessed from here.

We have also deployed on Vercel our [main application site](https://hive-mind-inky.vercel.app/) and the [server](https://hive-mind-server.vercel.app/) used for collaborative editing.

Unfortunately, however, we realise that Vercel does not support WebSockets, which means that our server, though successfully deployed, cannot function normally to send and receive data between collaborator accounts for shared projects in our application. *This has been totally out of our expectation so we did not have any time to deal with the issue, and so for the time being, running the server and the application on the localhost seems to be the only way to test the collaboration feature.*

On the authentication page, use either a registered e-mail account or Google to log in and be re-directed to the dashboard. After that, there should be an example project where you can view and test out the various functionalities of our editor.

## Timeline and Development Plan

- **7-15 May**
  - Finalised Lift-off video and poster.
  - Learn about relevant technologies: JavaScript, TypeScript, Git.
- **15-29 May**
  - Learn about relevant technologies: React, Node.js, MathJax.
  - Experiment basic features: modular input areas, real-time $\LaTeX$ rendering, hotkey binding.
- **30 May-10 June**
  - Implement fully modular note-editing (with drag-and-drop mechanism).
  - Implement $\LaTeX$ input and rendering.
  - Implement simple hotkey binding.
- **10-20 June**
  - Implement a prototype of project manager.
  - Continue to work on hotkey binding.
  - Implement hyperlink between notes components.
- **21-26 June**
  - Implement tags into the project manager (to be completed later than expected).
  - Test and fix potential bugs.
  - Prepare for Milestone II.
- **27 June-10 July**
  - Implement GUI illustration maker.
  - Work on styling of webpage.
  - Implement user account manager and login feature.
- **10 July-20 July**
  - Implement collaborative note-taking.
  - Continue working on styling of webpage.
  - (Tentative) Add more functions to the illustration maker.'
  - (Tentative) Add "export as PDF" and "export as $\LaTeX$ source code" functions to the notes editor.
- **21-24 July**
  - Test and fix potential bugs.
  - Prepare for Milestone III.

The **Project Log** is attached [here](https://docs.google.com/spreadsheets/d/1vAOZ7g_3GZcTc47UXCHAcNvJ3GAxhJOIIIlv9_ZGqss/edit#gid=0)

## Git Workflow

We did not have a specific Git workflow at the beginning of the project as we expected it to be light-weight and not require conscientious workflow control. However, as we approach milestone 2, we realise that the size of the project has grown tremendously with a significantly more complex code structure. For higher maintenability, we decided to set up the following Git workflow:

1. The `main` branch is **protected** and all pull requests merging to it require **code reviews** from both members of the team.

2. The `dev` branch is a non-protected branch hosting a stable working build of the application. It is the **only** branch that is allowed to be merged into `main` via pull requests.

3. Every new feature with a certain level of complexity needs to be implemented in a **separate non-protected** branch first.

4. Branches for implementing new features should be named with the feature name or a succint description, and attached with "(WIP)" at the end of branch name to indicate it is a *work-in-progress*.

5. Branches for experimenting new features and ideas should be named with a succint description and attached with "(EXP)" at the end of branch name to indicate its *experimental* nature.

6. All branches should be named in **kebab-case**.

7. When a new feature has been implemented, its work-in-progress branch should be merged into `dev` via pull requests. The code in `dev` should then be **immediately tested** to ensure that it works as expected.

8. After ensuring that the code in `dev` is without major issues, review the code and merge it with `main`. Then, the feature and experiment branches should be deleted accordingly.

9. The README shoud be updated timely to avoid any omission of details.

## Testing

To reduce the difficulty of the debugging process, we decided to run a brief test and debugging session once a feature has been changed significantly or a new functionality has been implemented, so that we aim to discover and address as many bugs as possible at an early stage. During testing, we should consider two key perspectives:

1. Does the feature/functionality work as intended on its own?
2. Does the feature/functionality interfere with other parts of the application built earlier?

Every bug spotted should be *immediately* recorded in **Github issues** with the following format:

> #### Description
> 
> A succint description of the bug.
> 
> #### Steps to Reproduce the Bug
> 
> What steps can be followed to reproduce the described bug on another device.
> 
> #### Expected Behaviour
> 
> What was expected to happen under the user's actions in place of the bug.
> 
> #### Other Useful Information
> 
> Any other information or contexts that might be relevant to the bug or useful for finding a fix.

The bug reports should then be investigated, after which a comment should be made to the original issue describing the cause of the bug. Once a bug has been fixed, we comment to the corresponding bug report issue to explain the methods and steps taken to tackle it, as well as any change in the application's behaviour after the fix. If after investigating the bug report, it is found that the bug cannot be fixed in a straightforward manner, a comment should also be made to explain the reason behind it and any applicable alternatives to avoid the bug.

### Test Case Design

Since the various features of our application are very closely linked, it is difficult to isolated each component to carry out unit testing. As such, we have chosen to conduct user testing directly once a major feature has been implemented. We focus on the edge cases mainly, as the basic functionalities should already been tested during the development process based on our workflow. For each tester, we would first ask them to freely navigate the application so that we can observe how easy it is for new users to accustom to our UI. Then, we ask them to perform a series of tasks which we deem as somewhat bug-prone, to see if any issue happens. Finally, we ask for their opinions on potential improvements and additions to the application which would be useful.

We now list down a few important test cases:

#### Inline Elements

By default, selecting an inline element and click on its corresponding button will toggle the element off. However, we would like to know what happens if the inline element is:

- partially selected, or

- selected together with another inline element, or

- selected together with formatted plain texts.

To test this, we prepared a mixed sentence. The first one third was plain text, the middle one third was an inline math block while the last on third was a link. We would then select half of the link, select the math block and the link together, and select the plain texts with the math block together respectively to test for the three target issues.

#### Discontinuous Headers

Based on the expected user input, headers should be set up *sequentially* in descending order, meaning that, for example, a sub-subsection only appears directly after a subsection and not a section or a chapter (so there is supposed to be no sudden jumps between header levels). In reality, however, this may not be the case, especially with the drag-and-drop mechanism where it is perfectly legal to move a subsection header such that it is then placed right after a chapter header.

Therefore, we tested this by inserting headers with discontinuous levels and observed their indexing behaviour. We found that if a section does not have higher level headers before it (e.g. when the first header of a document is already a section), it will be labelled as **0.1**, which seems weird and unintuitive. Similar problems also happened for subsections and sub-subsections.

To solve this problem, we added fallback mechanism that will forcefully revert the index to a single number if the above happens. For instance, if the first header of a document is a section, it will be labelled as section **1** rather than section **0.1**. For subsections and sub-subsections, we will forcefully convert them to the next higher level header if they appear disconnected with the other headers. For example, if the first header after a chapter title is a subsection, it is labelled as a **section** rather than a subsection.

#### Illegal User Input

One prominent issue with the matrix builder and function plotter is illegal user input. For example, the user may input things like `y = 2z + 1` for the application to plot when it is supposed to be a function of $x$ against $y$. When using the matrix builder, some user might also accidentally try to generate an identity matrix when the matrix is not a square matrix, or to transpose an augmented matrix which is mathematically meaningless. Such behaviours should be prevented such that they do not crash the application even if they do occur.

We first tested the function plotter. We tried to let it plot `y = s` and fortunately, the libraries we used to build the plotter have built-in mechanisms to address such inputs by not allowing an output graph to be produced. Additionally, we also tested for functions containing special constants like `y = \pi` and `y = x + e`, both of which worked perfectly.

Then, we tested the matrix builder focusing on non-square matrices. As expected, if matrix transformations which are supposed to be exclusive to square matrices get applied to these non-square matrices, bugs will occur, producing incorrect results or crashing the application. As such, we have disabled these transformations when the matrix builder detects that the user has input a size for a non-square matrix.

We followed up by testing the behaviour of the matrix builder when the matrix has empty entries. In particular, we wish to make sure that the preview and exported $\LaTeX$ are still accurate despite the presence of empty entries.
